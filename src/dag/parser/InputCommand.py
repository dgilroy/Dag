import re, getpass
from collections import UserList
from itertools import takewhile

import dag
from dag.lib.dot import DotDict

from dag.dagcli import directives, directive

from dag.identifiers import DagCmdTable
from dag.parser import lexer
from dag.parser import DagDirective as _DagDirective
from dag.parser.InputDagArg import InputDagArg
from dag.parser.InputCommandResponse import InputCommandResponse

from dag.dagcmd_exctx import DagCmdExecutionContext
from dag.dagmods import DagMod
from dag.dagcmds import DagCmd, CollectionDagCmd



class InputObjects(UserList):
	def last_nondirective(self):
		for obj in reversed(self.data):
			if not isinstance(obj, _DagDirective.DagDirective):
				return obj

	def latest_with_setting(self, setting):
		for obj in reversed(self.data):
			if hasattr(obj, "settings") and hasattr(obj.settings, setting):
				return obj.settings.setting

		return None





class InputCommand(DagCmdExecutionContext):
	def __init__(self, tokens = None, op = None, *, incmd_list = None):
		self.tokens = tuple(tokens) if tokens else ()
		# The op that ended the IC, which helps determine which next IC should run
		self.op = op or lexer.Tokens.SEMICOLON
		
		# If this InCmd was generated by CLI, include reference to the group of commands entered
		self.incmd_list = incmd_list

		self.initialize()


	@property
	def settings(self):
		return self.dagcmd.settings



	def reset(self):
		# Tuple so it's more immutable
		# Used for processing tokens. Set in initialize()
		self.proc_tokens = list(self.tokens)
		self.cmdtokens = []
		self.argtokens = []

		# This list will contain the dagmod/dagcmd/args in order of appearence (NOT directives/filts)
		self.inputobjects = InputObjects([dag.default_dagcmd])

		# Keeps track of how many times initialize() has been run. May be useful in the future for Alist commands
		self.init_attempts = 0 
		self.parser_attempts = 0 

		# IDENTIFIERS
		self.dagcmds = [dag.default_dagcmd]
		self.subcmdtable = dag.default_dagcmd.subcmdtable
		self.completion_dagcmd = dag.default_dagcmd
		self.completion_cmdtable = dag.default_dagcmd.completion_cmdtable

		# DAGMOD
		self.dagmod = None

		# DAGCMD
		self.dagcmd = None
		self.parent_dagcmds = []
		self.run_output_procssors = True

		# OUTPUT MODIFICATION INFO
		self.args = []
		self.directives = DotDict()
		self.directives2 = _DagDirective.DirectiveList()
		self.filts = {"filter": {}, "partition": []}
		self.filts_list = []
		self.drillbit = ""

		# Directive Processor
		self.directivelist = directive.DirectiveList()
		self.directiveexecutor = directive.DirectiveListExecutor(self)


		# Metasettings
		self.metadirectives = []

		# OUTPUT INFO
		self.outfile_active = False
		self.outfile_name = ""
		self.do_copy = False

		# PARSED
		self.raw_parsed = {}
		self.excess_tokens = []
		self.raw_parsed_with_spaces = {}	# Used by DagCompleter to determine active arg
		# All args passed into the parser
		self.inputargs = {}
		# Args passed into the parser as well as args generated by the parser
		self.parser_args = []
		self.parsed = {}

		# COMPLETION INFO
		self.complete_active = False
		self.space_suffix = ""

		# HOLDS Input Command Response
		self.response = None

		# MISC
		self.do_not_store = False

		# Fill out data
		#self.initialize()



	@property
	def settings(self):
		return getattr(self.dagcmd, "settings", {})


	def is_empty(self):
		return not bool([*filter(None, self.tokens)])


	def active_argtext(self):
		# Make self.tokens into self.args if I don't want possible dagmod/dagcmd names
		return "" if (self.space_suffix or not self.tokens) else self.tokens[-1]


	def is_current_directive(self):
		# Used by completer to fill out directive words
		return self.active_argtext_startswith("==")


	def is_current_filt(self):
		return self.active_argtext_startswith("##")


	def is_current_argname(self):
		return self.active_argtext_startswith("--")

	def is_current_drillbit(self):
		return self.active_argtext_startswith("::")


	def is_current_metadirective(self):
		return self.active_argtext_startswith("@@")


	def active_argtext_startswith(self, prefix):
		return self.active_argtext().startswith(prefix)


	def active_argname(self):
		argname = None

		for argname in self.raw_parsed.keys():
			argname = argname

		return argname


	def active_inputarg(self):
		inputarg = None
		
		for inputarg in self.inputargs.values():
			inputarg = inputarg

		nargs = nargs if (nargs := inputarg.settings.nargs) >= 0 else float("inf")
		
		if (nargs and isinstance(nargs, (float, int)) and len(inputarg.value) > nargs) or (inputarg.dagarg.settings.is_positional_dagarg and self.excess_tokens):
			inputarg = None

		return inputarg


	##METHODS FOR POPULATING INFO
	

	def process_directives(self):
		dirs = directives.directives
		short_directives = directives.short_directives

		directives2 = directive.directives
		short_directives2 = directive.short_directives

			
		# Process directives
		for idx, token in enumerate(self.proc_tokens):
			# Longform directives
			if token in dirs:
				dirs.get(token)(self)

				self.directivelist.add_if_valid(directives2.get(token))
				
			# Shortform directives
			if re.match("^=[a-zA-Z0-9]+$", token):
				for char in token[1:]:
					if char in short_directives:
						short_directives.get(char)(self)

					self.directivelist.add_if_valid(short_directives2.get(char))

		# Remove =,== directives
		for token in self.proc_tokens:
			if re.match("^==?[a-zA-Z0-9]+$", token):
				self.proc_tokens.remove(token)		


	def process_drillbit(self):
		for idx, token in enumerate(self.proc_tokens):
			if token.startswith("::"):
				self.drillbit = token[2:]
				self.proc_tokens.remove(token)


	def process_metadirectives(self):
		meta_active = False
		for idx, token in enumerate(self.proc_tokens):
			if token.startswith("@@"):
				value =token[2:]
				if value == "":
					meta_active = True
				else:
					self.metadirectives.append(value)

			elif meta_active:
				meta_active = False
				self.metadirectives.append(value)

			else:
				continue

			self.proc_tokens.remove(token)


	def process_filts(self):
		prefilts = [*takewhile(lambda x: not x.startswith("##"), self.proc_tokens)]

		if len(prefilts) == len(self.proc_tokens):
			return

		filttokens = self.proc_tokens[len(prefilts):] 
		self.proc_tokens = prefilts
			
		filtname = ""
		filtbuffer = None

		for filt in filttokens:
			if filt.startswith("##"):
				if filtbuffer is None:		# filtbuffer hasn't yet been used yet, so skip for now
					pass
				elif filtbuffer == []:		# Filtbuffer has been used but is currently empty, indicating a partition
					self.filts["partition"].append(filtname)
					self.filts_list.append(filtname)
				else:						# There are tokens in filtbuffer, indicating a filter
					self.filts["filter"].setdefault(filtname, [])
					self.filts["filter"][filtname].extend(filtbuffer)
					self.filts_list.append(filtname)

				filtname = filt[2:]
				filtbuffer = []
			else:
				filtbuffer.append(filt)

		if filtbuffer:						# Add last filttokens to filter
			self.filts["filter"].setdefault(filtname, [])
			self.filts["filter"][filtname].extend(filtbuffer)
			self.filts_list.append(filtname)
		else:								# Since no filttokens, put this into partition
			self.filts["partition"].append(filtname)
			self.filts_list.append(filtname)


	def process_output_directives(self):
		if ">" in self.proc_tokens[-1:]:
			self.do_copy = True 
			self.proc_tokens.pop(-1)
		elif ">" in self.proc_tokens:
			self.outfile_active = True

			idx = self.proc_tokens.index(">")
			self.proc_tokens.pop(idx)
			self.outfile_name = self.proc_tokens.pop(idx)



	####PARSING
	def set_raw_arg_values(self):
		self.raw_parsed = {}
		self.raw_parsed_with_spaces = {}

		tokens = self.proc_tokens
		dagcmd = self.dagcmd


		# Handle positional args
		arg_idx = 0

		while tokens and not tokens[0].startswith("--"):
			try:
				dagarg = dagcmd.dagargs[arg_idx]
				arg_idx += 1
				if dagarg.is_named_dagarg: break
			except (AttributeError, IndexError):
				break

			self.inputobjects.append(dagarg)

			nargs = dagarg.settings.nargs if dagarg.settings.nargs >= 0 else float('inf')
			nargs_idx = 0
			
			self.raw_parsed[dagarg.clean_name] = []
			self.inputargs[dagarg.clean_name] = InputDagArg(self, [], dagarg)

			while tokens and not tokens[0].startswith("--") and nargs_idx < nargs:
				value = tokens.pop(0)
				self.raw_parsed[dagarg.clean_name].append(value)
				self.inputargs[dagarg.clean_name].value.append(value)
				nargs_idx += 1

			
		
		# Handle kwargs	
		current_argname = ""
		while tokens:
			token = tokens.pop(0)
			if token.startswith("--"):
				current_argname = token[2:]
				self.raw_parsed[current_argname] = []

				dagarg = self.dagcmd.dagargs.get(current_argname)
				self.inputobjects.append(dagarg)
				self.inputargs[current_argname] = InputDagArg(self, dagarg = dagarg, name = token)
			else:
				self.raw_parsed.setdefault(current_argname, []).append(token)
				self.inputargs.setdefault(current_argname, InputDagArg(self, [], dagarg)).value.append(token)

		# Remove any empty inputargs from inputargs and raw_args
		self.raw_parsed_with_spaces = self.raw_parsed.copy()		# with_spaces is used by active_arg and DagCompleter
		for inputargname, inputarg in self.inputargs.copy().items():
			if inputarg.value == [""]:
				#del self.inputargs[inputargname]
				#del self.raw_parsed[inputargname]
				pass


	def validate_args_input_formatting(self):
		for inarg in self.inputargs.values():
			inarg.dagarg.validate_input_formatting(inarg)


	def run_parser(self, parse_while_valid = False):
		self.parsed = self.get_typed_parsed(parse_while_valid)


	# If a text is given, create ICResponse with given text, else, run the dagcmd and store
	def generate_response(self, response = None):
		if response is None:
			if self.metadirectives:
				breakpoint()
			else:
				response = self.run_dagcmd()

		return InputCommandResponse(self, response)


	def run_dagcmd(self, *args, **kwargs):
		run_fn = self.dagcmd.run_with_parsed

		if self.directives.update_dagcmd_cache:
			run_fn = self.dagcmd.update_with_parsed

		return run_fn(self.parsed)


	def parse_dagcmd(self):
		if self.is_empty() or not self.proc_tokens:
			return None

		dagcmd = self.dagcmds[0] # default dagcmd
		subcmdtable = dagcmd.subcmdtable
		tokens = self.proc_tokens[:]

		for i, token in enumerate(tokens):
			if token in dagcmd.subcmdtable:
				dagcmd = dagcmd.subcmdtable[token]
				subcmdtable = dagcmd.subcmdtable
				self.dagcmds.append(dagcmd)
				self.inputobjects.append(dagcmd)

				self.cmdtokens.append(self.proc_tokens.pop(0))
			else:
				break

		self.argtokens = tokens[i:]

		if isinstance(dagcmd, DagMod):
			with dag.ctx(active_dagcmd = dagcmd):
				dagcmd = dag.get_dagcmd(dagcmd.name).settings.default_cmd		
				self.dagcmds.append(dagcmd)


		self.set_dagcmd(dagcmd, subcmdtable, dagcmd.dagargs)



		if isinstance(dagcmd, CollectionDagCmd):
			#breakpoint()
			pass


	def set_dagcmd(self, dagcmd, subcmdtable = None, dagargs = None):
		self.dagcmd = dagcmd
		self.subcmdtable = subcmdtable or self.dagcmd.subcmdtable
		self.dagargs = dagargs or self.dagcmd.dagargs


	def parse_arguments():
		for token in self.proc_tokens[:]:
			breakpoint()
			pass


	def initialize(self):
		self.reset()

		self.init_attempts += 1

		# Handle dagmod/dagcmd
		self.parse_dagcmd()

		# Handle args/directives
		#self.parse_arguments()
		
		with dag.ctx(active_dagcmd = self.dagcmd):
			self.run_output_procssors = self.dagcmd and not self.dagcmd.settings.raw

			if self.run_output_procssors:
				self.process_directives()
				self.process_drillbit()
				self.process_filts()
				self.process_metadirectives()

				# This is here so that ">" works as command
				self.process_output_directives()

			# The above lines strip out args needed to resolve dagmods/dagcmds, leaving the command's args. Keep mention of those
			self.args = self.proc_tokens.copy()

			if not self.dagcmd:
				return self
			
			self.set_raw_arg_values()

			return self


	def __repr__(self): return dag.format(f"""
-------

<c b><INPUT COMMAND> <c magenta2 u>{' '.join(self.tokens)}</c>

    Dagmod: <c b>{self.dagmod}</c>
    Dagcmd: <c b>{self.dagcmd}</c>
    Args: <c b>{self.args}</c>
    Drillbit: <c b>{self.drillbit}</c>
    Directives: <c b>{self.directives}</c>
    Filts: <c b>{self.filts}</c>
    Raw_parsed: <c b>{self.raw_parsed}</c>
    Excess Tokens: <c b>{self.excess_tokens}</c>
    OP: <c b>{self.op}</c>

    Do Copy: <c b>{self.do_copy}</c>
    Outfile: <c b>{self.outfile_name}</c>

<c b></INPUT COMMAND>  <c magenta2 u>{' '.join(self.tokens)}</c>

-------
 
""")


	############ The Parser ######################


	def get_typed_parsed(self, parse_while_valid = False):
		from dag.parser import DagArgParser
		return DagArgParser.get_typed_parsed(self, parse_while_valid)



class ParsedCommand(dag.dot.DotAccess):
	def __init__(self, incmd, parsed):
		self.incmd = incmd
		self.parsed = parsed

	def __getattr(self, attr):
		return getattr(self.incmd, attr)