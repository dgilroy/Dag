import re, copy
from contextlib import contextmanager
from collections import UserList
from typing import Mapping

import dag
from dag.util import mixins

from dag import dagargs, tempcache
from dag.dagcli import outputprocessors, completers

from dag.parser import lexer, raw_arg_parser, commalists
from dag.parser.icresponses import InputCommandResponse
from dag.parser.inputobjects import InputObjects, InputObject, InputIdentifier
from dag.parser.inputdagargs import InputDagArg

from dag.dagcmd_exctx import DagCmdExecutionContext
from dag.cachefiles import cachefiles




#>>>> InputCommand
class InputCommand(DagCmdExecutionContext, InputIdentifier, mixins.CacheFileNamer):
	def __init__(self, tokens = None, terminus = None):
		self.tokens = tuple(tokens) if tokens else ()

		# The op that ended the IC, which helps determine which next IC should run
		self.terminus = terminus or lexer.Token.SEMICOLON

		self.initialize()


	@property
	def do_read_from_tempcache(self):
		return dag.settings.tempcache and not dag.settings.update_dagcmd_cache and tempcache.tempcachefiles.exists_from_dagcmd_exctx(self)


	@property
	def do_write_to_tempcache(self):
		return self.settings.enable_tempcache and not self.do_read_from_tempcache


	def _dag_cachefile_name(self):
		return " ".join(self.tokens)

	@property
	def is_should_store_input_info(self):
		return self.settings.store_ic_response


	@property
	def do_copy(self):
		return isinstance(self.outputprocessor, outputprocessors.ClipboardOutputProcessor)


	# Execute command callback	
	def get_callback_incmd(self):
		from dag.dagcmds import PartialDagCmd

		dagcmd = self.dagcmd
		callback = dagcmd.settings["callback"]

		if not isinstance(callback, (dag.DagCmd, PartialDagCmd)):
			if callable(callback):
				return callback()
			else:
				return callback

		ic = InputCommand()

		ic.set_dagcmd(callback)

		if getattr(callback, "locals", None): # used by PartialDagCmds
			ic.raw_parsed = {k: [dag.nab_if_nabber(v)] for k,v in callback.locals.items()}

		return ic	


	def reset(self):
		# Tuple so it's more immutable
		# Used for processing tokens. Set in initialize()
		self.proc_tokens = list(self.tokens)
		self.cmdtokens = []
		self.argtokens = []
		self.dagargs = dagargs.DagArgsList()
		self.dagargsmap = {}

		# This list will contain the dagmod/dagcmd/args in order of appearence (NOT directives/filts)
		defaultinputidentifier = InputIdentifier(dag.defaultapp)
		self.inputidentifiers = InputObjects([defaultinputidentifier])
		self.inputobjects = InputObjects([defaultinputidentifier])
		self.arguments = []

		# IDENTIFIERS
		self.dagcmds = dag.defaultapp.dagcmds
		self.is_default_cmd = False

		# DAGCMD
		self.dagcmd = dag.defaultapp # Starts with default dagcmd

		# OUTPUT MODIFICATION INFO
		self.args = []
		self.directives = dag.DotDict()

		# PARSED
		self.raw_parsed = {}

		# All args/dagargs passed into the parser
		self.inputargs = InputObjects()
		self.inputdagargs = {}
		
		# Args passed into the parser as well as args generated by the parser
		self.parsed = {}

		# Output Processor
		self.outputprocessor = outputprocessors.StandardOutputProcessor(self)


	@property
	def identifier(self):
		return self.dagcmd


	@property
	def name(self):
		return self.identifier.name


	def expand_parsed(self, parsed):
		#self.inputargs.execute("expand_parsed", parsed, self) -> Can't use execute because this needs to aggregated expanded parseds

		origparsed = parsed
		parseds = [parsed]
		for arg in self.inputargs:
			for parsed in parseds:
				newparseds = arg.expand_parsed(parsed)

				if newparseds:
					parseds = newparseds

		return parseds


	def add_inputarg(self, inputarg):
		self.inputargs.append(inputarg)
		self.inputobjects.append(inputarg)
		inputarg.process_incmd(self) #Processing after appending so that CollectionResourceMethodDagArg can remove itself


	@property
	def settings(self):
		return getattr(self.dagcmd, "settings", {})


	@property
	def is_empty(self):
		return not bool([*filter(None, self.tokens)]) or (len(self.tokens) == 1 and self.tokens[0] == "")


	@property
	def is_piped(self):
		return lexer.is_pipe(self.terminus)


	@property
	def active_argtext(self):
		# Make self.tokens into self.args if I don't want possible dagmod/dagcmd names
		return self.tokens[-1] if self.tokens else ""


	@property
	def is_current_argname(self):
		return self.is_current_long_argname or self.is_current_short_argname

	@property
	def is_current_long_argname(self):
		return self.active_argtext_startswith(dagargs.LONG_NAMED_PREFIX)

	@property
	def is_current_short_argname(self):
		return dagargs.is_short_named_arg(self.active_argtext)


	def active_argtext_startswith(self, prefix):
		return self.active_argtext.startswith(prefix)


	def active_argname(self):
		argname = None

		for argname in self.raw_parsed.keys():
			argname = argname

		return argname


	@contextmanager
	def set_inputargs(self, inputargs):
		try:
			oldinputargs = self.inputargs
			self.inputargs = inputargs
			yield
		finally:
			self.inputargs = oldinputargs


	@property
	def active_inputdagarg(self):
		inputarg = None
		
		for inputarg in self.inputdagargs.values():
			inputarg = inputarg

		if inputarg is None:
			return inputarg

		nargs = nargs if (nargs := inputarg.settings.nargs) >= 0 else float("inf")
		
		if (nargs and isinstance(nargs, (float, int)) and len(inputarg.rawvalue) > nargs):
			inputarg = None

		return inputarg


	def validate_args_input_formatting(self):
		for inarg in self.inputdagargs.values():
			inarg.dagarg.validate_input_formatting(inarg)


	def parse_dagcmd(self):
		from dag.applications import DagApp
		
		if self.terminus is lexer.Token.ATPIPE and self.tokens:
			self.proc_tokens[0] = "@" + self.tokens[0]
			self.terminus = lexer.Token.PIPE

		if self.is_empty or not self.proc_tokens:
			return None

		dagcmd = self.dagcmd # default dagcmd
		tokens = self.proc_tokens[:]


		for i, token in enumerate(tokens):
			try: # Try, rather than has_dagcmd, so that regex cmds have a chance to be found
				dagcmd = dagcmd.get_dagcmd(token)
				inputdagcmd = InputIdentifier(dagcmd)
				self.inputobjects.append(inputdagcmd)
				self.inputidentifiers.append(inputdagcmd)

				# If is regex command: Don't pop the token because it'll be passed as an argument into the dagcmd
				if dagcmd.is_regexcmd:
					break

				self.cmdtokens.append(self.proc_tokens.pop(0))
			except (TypeError, ValueError) as e:
				break

		self.argtokens = tokens[i:] if self.proc_tokens else [] # If no proc_tokens left, then there were no args

		if isinstance(dagcmd, dag.DagApp) and dagcmd.default_dagcmd:
			with dag.ctx(active_dagcmd = dagcmd):
				dagcmd = dagcmd.default_dagcmd
				self.is_default_cmd = True

		self.set_dagcmd(dagcmd)


	@property
	def active_identifier(self):
		return self.inputidentifiers[-1]


	@property
	def active_inputobject(self):
		return self.inputobjects[-1]


	def set_dagcmd(self, dagcmd):
		with dag.ctx(active_dagcmd = dagcmd):
			self.dagcmd = dagcmd
			self.dagcmds = copy.copy(self.dagcmd.dagcmds if not self.is_default_cmd else self.dagcmd.parents[-1].dagcmds) # DEEPCOPY ON THIS ADDED 50 MS TO DEFAULT DAGCMD COMPLETION

			if hasattr(self.dagcmd, "dagargs"): #BC sometimes dagcmd is a dagapp
				self.dagargs = (self.dagcmd.dagargs).copy()

			self.dagcmd.process_incmd(self) # This is here because display fns can have their own args (see "pokemon pokedex")


	def initialize(self):
		self.reset()

		# Handle dagmod/dagcmd
		self.parse_dagcmd()
		
		with dag.ctx(active_dagcmd = self.dagcmd):				
			# The above lines strip out args needed to resolve dagmods/dagcmds, leaving the command's args. Keep mention of those
			self.args = self.proc_tokens.copy()

			if not self.dagcmd:
				return self
			
			self.rawparser = raw_arg_parser.RawArgParser(self, default_argclass = InputDagArg)
			self.rawparser.parse_args()

			with dag.ctx(directives = self.directives):
				if not dag.ctx.skip_validate_inputarg:
					self.validate_args_input_formatting()
				#if not dag.ctx.skip_type_parser:
				#	self.run_type_parser()

			return self


	def cachefile_exists(self):
		return cachefiles.exists_from_dagcmd_exctx(self)


	@property
	def is_cached_collection(self):
		from dag import collectiondagcmds
		return self.cachefile_exists() and isinstance(self.dagcmd, collectiondagcmds.CollectionDagCmd) and self.dagcmd.settings.cache


	def execute_all_but_last_inputarg(self):
		inputargs = self.inputargs[:]
		if self.inputargs:
			inputargs.pop()

		with self.set_inputargs(inputargs):
			return self.generate_response()


	def generate_response(self, response, parsed):
		if response is None:
			response = self.run_dagcmd(parsed = parsed)

		icresponse = InputCommandResponse(self, response)

		self.inputargs.execute("filter_icresponse", icresponse)
		self.inputargs.execute("process_icresponse", icresponse)

		return icresponse


	def run_dagcmd(self, parsed = None):
		return self.dagcmd.run_with_parsed(parsed = parsed, update_cache = self.directives.update_dagcmd_cache)


	@property
	def text(self):
		return " ".join(self.tokens)


	def __repr__(self):
		inputobjectsstr = [f"{i.obj.__class__}(<c #F00 / {i.obj.name}>)" for i in self.inputobjects]

		return dag.format(f"""
-------

<c b><INPUT COMMAND> <c magenta2 u>{self.text}</c>

    Dagapp: <c b>{self.dagcmd.root}</c>
    Dagcmd: <c b>{self.dagcmd}</c>
    Args: <c b>{self.args}</c>
    Directives: <c b>{self.directives}</c>
    Raw_parsed: <c b>{self.raw_parsed}</c>
    OP: <c b>{self.terminus}</c>
    InputObjects: <c b>{inputobjectsstr}</c b>>

<c b></INPUT COMMAND>  <c magenta2 u>{self.text}</c>

-------
 
""")
#<<<< InputCommand






#>>>> InputCommandBuilder
class InputCommandBuilder:
	def __init__(self, tokens: list[str] = None, terminus: lexer.Token | None = None, *, incmdlist = None) -> None:
		self.tokens = tokens
		self.terminus = terminus or lexer.Token.SEMICOLON
		self.incmdlist = incmdlist


	def buildincmds(self) -> list[InputCommand]:
		tokenlists = commalists.expand_commalist(self.tokens)

		incmds = []
		for tokenlist in tokenlists:
			with dag.bbtrigger("buildincmd"):
				incmd = InputCommand(tokens = tokenlist, terminus = self.terminus)

			incmd.inputargs.execute("process_incmd", incmd)

			incmds.append(incmd)

		return incmds
#>>>> InputCommandBuilder


#>>>> Parsed Incmd
class ParsedInputCommand(dag.dot.DotProxy):
	def __init__(self, incmd: InputCommand, parsed) -> None:
		super().__init__(incmd)
		self.incmd = incmd
		self.parsed = parsed

		# COMPLETER
		self.completer = completers.InputCommandCompleter(self)


	def complete(self, word):
		return self.completer.complete(word, self.parsed)


#<<<< Parsed Incmd
